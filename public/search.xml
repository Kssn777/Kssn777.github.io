<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode做题记录01</title>
    <url>/2021/11/24/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%9501/</url>
    <content><![CDATA[<h1 id="允许重复选择元素的组合"><a href="#允许重复选择元素的组合" class="headerlink" title="允许重复选择元素的组合"></a>允许重复选择元素的组合</h1><p>点击<a href="https://leetcode-cn.com/problems/Ygoe9J/">这里</a>查看原题</p>
<p><img src="https://img-blog.csdnimg.cn/bcadc6874f0c412fba7231280c6b6a2c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一个组合问题，从最简单想到的办法出发    <strong>暴力解法</strong></p>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>用一个for循环遍历数组每一个数，一直寻找符合条件的数加到集合中，代码就不贴了，很难写。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>一般来讲，改进暴力写法的方法可以用回溯+剪枝来避免一些不必要的遍历。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//保存答案</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        find(candidates,target,target,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),<span class="number">0</span>);           </span><br><span class="line">        <span class="keyword">return</span> ans;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*定义一个查找方法，参数除了默认的两个之外，now用来检查candidates[i]是否</span></span><br><span class="line"><span class="comment">    能被添加进combine集合，combine用来装合格的数，x稍后再解释</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> now,List&lt;Integer&gt; combine,<span class="keyword">int</span> x)</span></span>&#123;       </span><br><span class="line">        <span class="keyword">if</span>(now == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combine));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;candidates.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(now - candidates[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    combine.add(candidates[i]);</span><br><span class="line">                    find(candidates,target,now - candidates[i],combine,i);</span><br><span class="line">                    <span class="comment">//回溯</span></span><br><span class="line">                    combine.remove(combine.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码的整体思路"><a href="#代码的整体思路" class="headerlink" title="代码的整体思路"></a>代码的整体思路</h3><p>总体来看，其实也是一种暴力遍历的过程，但是会避免很多不必要的遍历，以candidates=[2,3,5]     和  target=5为例，一开始，now的值为5，每一次遍历都会减去candidates[i]，结果如果大于等于0则把candidates[i]加进combine集合里，一直递归下去，如图（部分步骤）：<br><img src="https://img-blog.csdnimg.cn/a1a7e444507c4e41ae0e5f6f1d3d2b4a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>红色代表正确的结果</p>
<h3 id="关于x的解释："><a href="#关于x的解释：" class="headerlink" title="关于x的解释："></a>关于x的解释：</h3><p>如果我们不用x，算法就是这样执行的：</p>
<p>以candidates=[2,3,5]     和  target=5为例，先遍历到2，然后发现[2,3]是满足的，添加到ans，回溯，遍历到3，发现[3,2]是满足的，添加到ans，这就出现了问题，[2,3]和[3,2]是重复的！<strong>那问题出在哪里了呢？</strong></p>
<p>那是因为遍历时，会“忘记”之前遍历过的结果，也就是说，只能遍历自己以及以后的数组，比如遍历到i=1，就只能遍历i &gt;= 1 以后的数字，这样子就不会重复了，所以x的目的就是用来防止这个现象的发生。<br><img src="https://img-blog.csdnimg.cn/49ed30ddca294da0aaf062d12676ff5b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode做题记录02</title>
    <url>/2021/11/24/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%9502/</url>
    <content><![CDATA[<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>点击<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">这里</a>查看原题</p>
<p><img src="https://img-blog.csdnimg.cn/144a333b64d748108b390290c0f71b4e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实整体思路很简单，用一个now变量记录当前遍历的节点，用一个prev变量记录当前节点的上一个节点，再用一个next变量记录now变量的下一个节点，就可以这样操作了：next节点先保存着now节点的下一个节点，然后把now节点的next指向prev达到反向的目的，最后把next赋值给now即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>,now = head;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = now.next;</span><br><span class="line">            now.next = prev;</span><br><span class="line">            prev = now;</span><br><span class="line">            now = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然是简单题，但是好像挺常考的，要注意一下。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode做题记录04</title>
    <url>/2021/11/24/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%9504/</url>
    <content><![CDATA[<h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h3><p>点击<a href="https://leetcode-cn.com/problems/lru-cache/">这里</a>查看原题</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据你所学的数据结构，设计一个LRUCache类，以capacity为容量，有put(int key,int value) 方法和 get(int key)方法，当容量已满，要把最久未使用的数据删掉再加入新的数据。并且要求put和get方法的时间复杂度为O(1)</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>既然要求get()方法的时间复杂度为O(1)我们自然要想到hash表，只有hash表这种结构才能使得获取数据的时间复杂度为O(1)，因此类里面一定有一个成员变量是HashMap，那么另一个问题又来了，HashMap的键值应该是什么呢？我们后面再讲。</p>
<p>接下来是put()方法要怎么才能做到O(1)的时间复杂度了，要把数据以O(1)的复杂度插入，我们自然能想到链表，因为只需要把数据放到尾部就可以了，那我们暂定使用单向链表。那我们定义，越靠近头部的，是越久未被使用的，既然如此，我们就一定要有一个删除数据的方法，如果用单向链表来实现，那么删除数据的方法的时间复杂度必定超过O(1)，所以我们只能使用双向链表了。</p>
<p>到了这里，我们已经确定了要使用的数据结构，HashMap和双向链表。先讲讲双向链表，每一个节点应该这样设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node prev;<span class="comment">//指向上一个结点</span></span><br><span class="line">        Node next;<span class="comment">//指向下一个节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而且，为了方便，我们可以把HashMap的键值对设置为：键为key，值为结点，也就是一个key对应一个结点，因为到时候使用删除结点方法的时候可以由key直接定位结点，方便删除。完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//已经放入的数据的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap(capacity);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> Node();<span class="comment">//哑头结点</span></span><br><span class="line">        tail = <span class="keyword">new</span> Node();<span class="comment">//哑尾结点</span></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;<span class="comment">//头尾相连</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            removeNode(n);</span><br><span class="line">            addNode(n);</span><br><span class="line">            <span class="keyword">return</span> n.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="keyword">null</span>)&#123;</span><br><span class="line">            addNode(<span class="keyword">new</span> Node(key,value));</span><br><span class="line">            <span class="keyword">if</span>(size&gt;capacity) removeNode(head.next);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            removeNode(n);</span><br><span class="line">            addNode(<span class="keyword">new</span> Node(key,value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        map.remove(node.key);</span><br><span class="line">        --size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        tail.prev.next = node;</span><br><span class="line">        node.prev = tail.prev;</span><br><span class="line">        node.next = tail;</span><br><span class="line">        tail.prev = node;</span><br><span class="line">        map.put(node.key,node);</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>讲讲哑结点的设置的原因吧，如果我们不设置哑结点，我们在删除和添加元素的时候都要判断一下还未插入数据的情况，很烦，加入哑结点就可以避免这种情况。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode做题记录03</title>
    <url>/2021/11/24/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%9503/</url>
    <content><![CDATA[<h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p>点击<a href="https://leetcode-cn.com/problems/unique-paths/">这里</a>查看原题<br><img src="https://img-blog.csdnimg.cn/bd0a0b0ca1de4e4982d086f27f57c0f0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>类似这种有多少条路径/多少种方法/多少XXX的题目，类似于策划类的算法题，一般都能用动态规划来解决，而动态规划最重要是写出其状态转移方程，我们回到题目，题目的入参是m和n，因此我们可以设定一个函数f(m,n)，其表示以m为行数以n为列数的棋盘上，机器人从左上角出发每次只能向右走或者向下走一步，一共有f(m,n)种路径。</p>
<p>假设棋盘是三行两列，即m=3，n=2，如果机器人是向下走，那么m就减一，相当于机器人从两行两列的棋盘的左上角出发，也就是f(2,2)，假设机器人是向右走，那么n就减一，相当于机器人从三行一列的棋盘的左上角出发，也就是f(3,1)，我们可以发现，f(3,2)=f(2,2)+f(3,1)，而且，当m=1或者n=1时，函数值为1，也就是只有一种方法了，因此我们可以写出状态转移方程：</p>
<p>$ f(m,n)=f(m-1,n)+f(m,n-1),m＞1或n＞1 $<br>$f(m,n)=1,else$​</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道非常常规的动态规划题目，比较简单</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode做题记录05</title>
    <url>/2021/11/24/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%9505/</url>
    <content><![CDATA[<h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><p>点击<a href="https://leetcode-cn.com/problems/binary-tree-tilt/">这里</a>查看原题</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，计算 <strong>整个树</strong> 的坡度 。</p>
<p>一个树的 <strong>节点的坡度</strong> 定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值</strong> 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。<br><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>
<p><img src="https://img-blog.csdnimg.cn/b30e0387ddf14c72be40e4e14e5960e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>既然我们要求所有节点的坡度，那么我们必定要遍历每一个节点，三种方法，前序中序后序，而我们发现，叶子结点的坡度必定为0，因此我们可以从叶子结点来出发，既然每一个结点的坡度都等于其左子树所有节点的和与其右子树所有节点的和之差的绝对值，那么我们就先使用后序遍历算法来求。</p>
<p>在后序遍历中，我们可以做一点小改进：只要遇到了叶子结点，我们就直接返回，如果没有遇到叶子结点，就把当前节点的值加上其左节点的与右结点的值，因为我们是从叶子几点出发！因此在之后的递归中，每一个非叶子结点已经保存了其左子树所有节点的和与其右子树所有节点的和了！</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        postorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//遇到叶子结点返回</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">        postorder(root.left);</span><br><span class="line">        postorder(root.right);  </span><br><span class="line">        <span class="comment">//注意，如果左子树或者右子树为空，我们就认为其坡度为0，因此用一个三目运算来代替 </span></span><br><span class="line">        root.val = root.val + </span><br><span class="line">        (root.left==<span class="keyword">null</span>?<span class="number">0</span>:root.left.val)</span><br><span class="line">         + (root.right==<span class="keyword">null</span>?<span class="number">0</span>:root.right.val);</span><br><span class="line">        </span><br><span class="line">        ans += Math.abs((root.left==<span class="keyword">null</span>?<span class="number">0</span>:root.left.val) - (root.right==<span class="keyword">null</span>?<span class="number">0</span>:root.right.val));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode做题记录06</title>
    <url>/2021/11/24/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%9506/</url>
    <content><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>点击<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">这里</a>查看原题</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串s，输出它最长的回文子串<br><img src="https://img-blog.csdnimg.cn/597216c9fbc940fe8232a15d9fbe55d5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="Manacher-马拉车-算法"><a href="#Manacher-马拉车-算法" class="headerlink" title="Manacher(马拉车)算法"></a>Manacher(马拉车)算法</h2><p>其实本篇文章注重想讲讲这个Manacher算法。其实这个题目我们容易想到，遍历字符串s的每一个字符，假设遍历到i，那么就把这个字符当做<strong>回文中心</strong>，即回文串的对称轴，然后从两边开始扩张，直到不是回文的为止，记录下来最大长度的起点与终点即可，这种算法叫<strong>中心扩展法</strong>。中心扩展法还得分回文中心长度为1和2两种情况考虑，因此时间复杂度为O(n²)。</p>
<p>而Manacher算法运用了动态规划+中心扩展法优化了上述算法，充分利用了回文串的对称性。</p>
<p>首先，我们得把字符串的每一个空隙都加上一个不可能存在的字符，比如说’#’，如图<img src="https://img-blog.csdnimg.cn/e82ec9d812f743e0b686f48a8716a7c3.png" alt="在这里插入图片描述"><br>为什么要这样做呢？原因是要把字符串长度变为奇数，这样就可以不用讨论回文中心的长度是1是2的情况了。<strong>证明：假设len为原字符串长度，一共有len-1个空隙，加上头尾两个符号，因此新字符串长度为 len + len -1 + 2 = 2*len + 1是一个奇数</strong>。</p>
<p>同时，我们可以发现，在新字符串中，以某一个字符为回文中心的<br><strong>（最大回文子串长度 - 1）/2 = 原来字符串中以该字符为回文中心的回文子串长度 = 从该字符出发走到最右端所需步数(即回文半径)</strong></p>
<p>因此我们把所有以i为回文中心的回文半径求出来即可。</p>
<p>为了下面能解释的更清楚，先说明几个定义：<br> <strong>1. 回文半径r：从回文中心出发，走到该回文串最右端所需距离。<br> 2. f(i)：i为回文中心，f(i)则是以i为回文中心的最大回文半径。<br> 3. maxRight：某个回文中心的最大回文子串的最右端的下标。</strong></p>
<p>本算法最根本的思路就是通过动态规划和中心扩展法求出每一个f(i)，<br>我们可以考虑以下两种情况：</p>
<h3 id="当-i-gt-maxRight"><a href="#当-i-gt-maxRight" class="headerlink" title="当 i &gt;= maxRight"></a>当 i &gt;= maxRight</h3><p><img src="https://img-blog.csdnimg.cn/3cfb05e272e342bbbbeaec4e0b9a7ca4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>（注意，图中的s是加了符号填充之后的字符串）<br>当 i &gt; maxRight 时，我们只能根据中心扩展法法来求出以i为回文中心的最大回文子串长度。</p>
<h3 id="当-i-lt-maxRight"><a href="#当-i-lt-maxRight" class="headerlink" title="当 i &lt; maxRight"></a>当 i &lt; maxRight</h3><p>这种条件下我们就要充分利用回文串的对称性来求出f(i)<br>我们可以分三种情况讨论：<br><strong>注意：以下的mirror都是i关于center的对称点</strong></p>
<p>①f(mirror) &lt; maxRight - i<br><img src="https://img-blog.csdnimg.cn/27aefedb0e7f41fabf201d13895d63a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>这种情况可以这样描述：f(mirror)要小于mirror到左端点的距离，而根据对称性，mirror到左端点的距离等于i到maxRight的距离，因此有： f(mirror) &lt; maxRight - i<br>那么f(i)该怎么求呢？我们很容易想到，<strong>在i到maxRight之间的每一个字符与i到center之间的每一个字符都分别与mirror到左端点之间的每一个字符和mirror到center之间的每一个字符对称。</strong> <code>因此f(i) = f(mirror)</code></p>
<p>②f(mirror) = maxRight - i<br><img src="https://img-blog.csdnimg.cn/0c9962524bf947c2af62e4fb9097220d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当这种情况时，我们最多只能确认f(i) &gt;= maxRight - i的，因为根据对称性，很容易就得出来，<strong>以i为中心，半径为maxRighht - i 的子串必定回文</strong>，但是我们无法确认，扩充之后是否还是回文串，我们只能这样描述：<code>当f(mirror) = maxRight - i ，f[i]至少等于maxRight - i，然后再以maxRight为中心进行中心扩展</code></p>
<p>③f(mirror)  &gt;  maxRight - i<br><img src="https://img-blog.csdnimg.cn/8daf934a31d2486388fbc944def241ce.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在②中，我们很容易得出，f(i) = maxRight - i ，那么为什么f(i) 有可能等于 f(mirror)吗，答案是不可能，假设f(i) = f(mirror)，也就是说，以center为中心的最大子串的最右端应该大于maxRight，因此矛盾。所以，<code>f(i) = maxRight - i</code> </p>
<p>综上所述：<br>当i&gt;=maxRight ，只能通过中心扩展法得出f(i)<br>当i&lt;maxRight，f(i)&gt;= min{ f(mirror)，maxRight - i }，再尝试中心扩展法</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        String newStr = sb.toString();</span><br><span class="line">        <span class="keyword">int</span> newLength = newStr.length();</span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>,maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;newLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;maxRight)&#123;</span><br><span class="line">                <span class="keyword">int</span> mirror = <span class="number">2</span>*center - i;</span><br><span class="line">                f[i] = Math.min(f[mirror],maxRight - i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试进行中心扩展法</span></span><br><span class="line">            <span class="keyword">int</span> left = i - f[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = i + f[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;newLength &amp;&amp; newStr.charAt(left) == newStr.charAt(right))&#123;</span><br><span class="line">                --left;</span><br><span class="line">                ++right;</span><br><span class="line">                f[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果扩展完后发现此时最右端的下标比maxRight大，就要重置</span></span><br><span class="line">            <span class="keyword">if</span>(i + f[i] &gt; maxRight) &#123;</span><br><span class="line">                maxRight = i + f[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//记录最大长度</span></span><br><span class="line">            <span class="keyword">if</span>(r[i] &gt; maxLen)&#123;</span><br><span class="line">                maxLen = f[i];</span><br><span class="line">                <span class="comment">//这个起点的计算方法读者自行证明吧</span></span><br><span class="line">                start = (i - maxLen)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start + maxLen);</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql在RR级别下如何解决幻读</title>
    <url>/2021/11/24/Mysql%E5%9C%A8RR%E7%BA%A7%E5%88%AB%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>在RR级别下，Mysql是根据MVCC来解决快照读时发生的幻读现象，简单来说就是利用了版本链以及Read View来实现的，RR下每一次快照读都会产生Read View 因此只有一个数据模板从而避免幻读，关于MVCC的原理可以看我之前发过的文章：<br><a href="https://blog.csdn.net/weixin_46180709/article/details/121428830">Mysql MVCC的原理</a></p>
<h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>重点讲讲当前读是如何解决幻读问题的。<br>当前读是经过加锁来解决幻读的问题的，我们先来聊聊加锁的机制。</p>
<ol>
<li>如果where子句里通过非索引项来查找数据，则会使用表锁。</li>
<li>如果通过普通索引来查找数据，则会使用间隙锁。</li>
<li>如果使用唯一索引来查找数据，则会降级为行锁。</li>
<li>如果使用唯一索引查找一条不存在的数据，则会使用间隙锁。</li>
<li>如果使用唯一索引范围查找，则会使用间隙锁。</li>
</ol>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>间隙锁就是用来锁住当前行记录两边“空白”的部分，比如说现在有id = 2,5,7的数据，如果执行了一条select * from user where id &gt; 6 for update 的语句，则会锁住[5,+∞]的区间，再次区间上的所有当前读操作都会被锁住。</p>
<p>因此在RR级别下，当前读同一条sql语句一定会读到相同的数据，或者会发生阻塞。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：解决了幻读问题<br>缺点：容易发生死锁</p>
]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的MVCC原理</title>
    <url>/2021/11/24/Mysql%E7%9A%84MVCC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>我们知道，在Mysql的RC隔离级别下和RR隔离级别下MVCC才会生效，它的实现原理是靠undo log版本连以及Read View来实现的，下面我们来分析一下。</p>
<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>快照读很简单，其实就是普通的select，是一种非阻塞无锁操作。</p>
<h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>读的是当前最新的数据，比如 select ···· for update，insert，update等都是当前读，是要加锁的。</p>
<h2 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h2><p>在每一行记录的后面其实会有两个隐藏字段<br><strong>DB_TRX_ID</strong>：保存在该行记录上执行insert语句或者update语句的当前事务ID。<br><strong>DB_ROLL_PTR</strong>：回滚指针，记录着该记录的上一个版本，相当于链表的next指针。</p>
<h1 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h1><p>Read View是进行快照读的依据，是一种数据结构，它由四个部分组成</p>
<ol>
<li>m_ids：当前活跃的所有事务ID</li>
<li>min_trx_id：最小活跃事务ID</li>
<li>max_trx_id：下一个事务ID，最大活跃事务ID + 1</li>
<li>creator_trx_id：创建该Read View的事务ID</li>
</ol>
<p> 对每一个事务，只能读到小于等于DB_TRX_ID(<strong>行记录的隐藏字段</strong>)的版本的数据，比如说现在的事务ID是4，它只能读到1到4版本的数据，那么该读哪个版本呢？要遵循以下逻辑：<br> （注意：以下的<strong>当前事务ID</strong>是指版本链中记录的每一个已操作的事务ID）</p>
<ol>
<li>判断当前事务ID是否等于creator_trx_id，如果相等，表示是自己修改了自己，当然可以访问，如果不相等，进入下一轮判断。</li>
<li>判断当前事务ID是否小于min_trx_id，如果小于，表示事务已经提交，当然可以访问，如果不相等，进入下一轮判断。</li>
<li>判断当前事务ID是否大于max_trx_id，如果大于，则表示该事务实在ReadView生成以后再开启的，不允许访问，如果小于，则进入下一轮判断。</li>
<li>判断当前事务ID是否  min_trx_id &lt;= DB_TRX_ID &lt;= max_trx_id ，如果成立，则看看该事务ID是否在m_ids中，如果不存在，则表明事务已提交，可以读取。</li>
</ol>
<p>而RC隔离级别和RR隔离级别的区别就在于产生Read View的时机。</p>
<h4 id="RC隔离级别下的情况"><a href="#RC隔离级别下的情况" class="headerlink" title="RC隔离级别下的情况"></a>RC隔离级别下的情况</h4><p>在RC隔离级别下，在每次进行快照读的时候，都会生成Read View，因此每次快照读都能知道是哪些数据没有提交，再经过上述判断后，每次快照读都会读到已提交的数据，因此才会出现不可重复读的现象。</p>
<p>如图<img src="https://img-blog.csdnimg.cn/3431dbcfb9434e41bd565dfedb5cc71b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>InnoDB是以每一个版本链的DB_TRX_ID去比较的，一个不行就下一个直到拿到数据为止，整个过程是这样的：先从DB_TRX_ID = 2开始，发现2不等于creator_trx_id，因此下一轮循环，然后再发现2不小于min_trx_id，进入下一轮循环，发现2小于max_trx_id，进入下一轮循环，发现2是在m_ids里的，不符合，因此根据回滚指针，指向下一个版本即DB_TRX_ID = 1，再次经过上述逻辑，发现符合，因此取出DB_TRX_ID = 1的这条数据，因此第一次快照读读的是name = B，而同理，第二次快照读读的是name = C。</p>
<h3 id="RR隔离级别下的情况"><a href="#RR隔离级别下的情况" class="headerlink" title="RR隔离级别下的情况"></a>RR隔离级别下的情况</h3><p>RR隔离级别下的情况和RC隔离级别几乎完全相同，唯一不一样的地方就是，RR级别只会生成一次Read View，之后的每次快照读都会根据这个Read View 来读，但是要注意一点，如果有当前读发生，则会清除Read View并且重新生成一个新的Read View，因此MVVC只是可以解决部分的幻读现象。</p>
]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的事务日志</title>
    <url>/2021/11/24/Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>Mysql的常见的事务日志有这么几个：redo log，undo log，bin log。</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>先讲讲undo log吧。我们都知道，mysql在执行事务时，是可以进行回滚操作的，那么这个回滚操作究竟是如何实现的呢？<br>这是通过<strong>MVCC(Multi Version Concurrency Control，多版本并发控制</strong>)实现的，其实就是每行记录都有不同的版本，形成一条版本链，可以通过无锁的方式访问到不同版本的数据，而MVCC就是通过undo log实现的。<br>简单理解，undo log就是记录了事务中每一个操作的<strong>逆向操作</strong>，比如说，在t=1时，增加了一行记录，那么undo log就会记录一句：<strong>删除这一行操作</strong>。<br>但是，InnoDB并不会真的会为每一个行记录去开辟一个新空间去存储不同版本的数据，也就是说，B+树的叶子结点只会存储最新版本的数据，只不过InnoDB可以根据undo log去得到行记录的不同版本。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>该日志是InnoDB特有的日志，记录了哪个数据页进行了哪些改动，是一种物理日志，redolog是为了实现事务的持久性的，每当事务提交的时候，就把redo log持久化到硬盘上。redo log会有个重做日志组，里面有redo log 1，redo log 2等等，每次写入redo log时是顺序写的，比如说redo log1写满了，就会写到redo log 2，如果全满了，就会把脏页刷回磁盘先，因此redo log写入磁盘速度是比较快的。</p>
<p>carsh - safe的原理也是因为redo log</p>
<h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><p>bin log也称归档日志，主要是用于主从复制和恢复，是一种逻辑日志，可以理解为存储了一条sql语句，而该日志是在Server层，也就是说只要是Mysql，都会有bin log。bin log是随机写入磁盘的，因此bin log可以认为是无限大的。</p>
<h2 id="为什么binlog不能用于crash-safe"><a href="#为什么binlog不能用于crash-safe" class="headerlink" title="为什么binlog不能用于crash-safe"></a>为什么binlog不能用于crash-safe</h2><p>假设我们只有binlog，如果在事务提交前，binlog写成功之后，发生了crash，那么当数据库恢复之后，binlog就会多出来提交前的数据，造成数据不一致，如果事务提交了之后，binlog没有写完，发生了crash，数据库恢复之后，就会少了提交后的数据，又造成了数据不一致，因此仅仅用bin log是不可以达到crash-safe。</p>
<h2 id="那么redo-log和bin-log怎么配合呢"><a href="#那么redo-log和bin-log怎么配合呢" class="headerlink" title="那么redo log和bin log怎么配合呢"></a>那么redo log和bin log怎么配合呢</h2><p>经过上面的分析，我们知道，一定要redo log 和 bin log互相配合才可以达到crash-safe的能力，数据库恢复使用的是redo log，而从服务器要根据bin log实现主从复制，同时我们还要保证redo log和bin log的逻辑一致，这样才能保证数据的一致性。</p>
<p>这里我们就要讲到<strong>两阶段提交</strong>了，指的是，事务提交时需要两个阶段，首先redo log先写到磁盘，此时事务状态为prepare，然后到bin log写盘，成功后事务状态标志位commit，此时才算事务提交成功，任何一个节点出错，都会进行回滚。</p>
<p>那么为什么要两阶段提交呢，互相独立不行吗？<br>我们设想一下，如果redo log写盘成功，bin log没有成功，那么当数据库发生crash之后，主数据库会利用redo log进行数据恢复，它的数据是新的，而从数据库会利用bin log进行主从复制，从数据库的数据就是旧的，这样就会造成数据不一致。<br>如果bin log写盘成功，而redo log写盘失败，当crash之后，主数据库的数据就是旧的，而从数据库的数据就是新的，也会数据不一致，因此两阶段提交就可以解决这种情况。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的各种索引</title>
    <url>/2021/11/24/Mysql%E7%9A%84%E5%90%84%E7%A7%8D%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>最近在各种文章上都看到了各种各样类型的索引，都快把我搞懵了，什么聚集索引，主键索引，聚簇索引等等，这里来整理一下</p>
<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>顾名思义，就是在主键上建立的索引，InnoDB中，主键索引的数据都会存到索引树的叶子结点上，而其他索引的叶子结点存储的都是主键字段的值，<strong>因此主键索引也就是聚集索引也就是聚簇索引，因为数据都聚集在叶子节点上</strong>。</p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>建立在唯一约束的字段上的索引，唯一索引既可以是主键索引也可以是普通索引。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引指的是要查询的数据列被所建的索引覆盖了，比如说现在有个表，主键是id，有name，age两个字段，在age上建立索引，现在执行这个语句：select id from user where age = 23；    那么就会从age字段上的索引树上找，因为age是普通索引，因此其叶子结点上存储的是主键字段的值，也就是id，因此就可以直接返回，不用回表了。要是执行的是select name from user where age = 23，就会先从age上的索引树出发，<strong>先找到age = 23锁对应的id，再去主键索引树上根据这个id找到对应的行记录返回（这就是回表</strong>）。</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>以上述例子，主键是id，有name，age两个字段，现在改为，有name，age，phone三个字段，以（name，age）建立联合索引，执行以下语句：select * from user where name like ‘张%’ AND age = 23； 在5.6以前，是这样执行的<br><img src="https://img-blog.csdnimg.cn/f06eecb802ce4621a4ee7eb964e9ff6e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>需要<strong>回表两次</strong><br>而有了索引下推后，就变成<br><img src="https://img-blog.csdnimg.cn/ccd54c540b2244caa842d85678fd8107.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>只需要一次了，这种优化就叫索引下推。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>再说说索引失效的几个场景吧：</p>
<ol>
<li>在检索条件中没有遵循最左前缀原则，比如联合索引(name,age)，而检索条件中只用了age，会导致索引失效。</li>
<li>在使用like模糊查询时，%放在了前面，比如说name like ‘%某’，也会导致索引失效。</li>
<li>在where子句中对索引字段进行运算也会导致索引失效。</li>
<li>在where子句中对索引字段进行函数运算也会导致索引失效。</li>
<li>在where子句中对索引进行!=或&lt;&gt;的时候有可能会导致无法使用索引</li>
<li>用or来连接也会导致索引失效</li>
<li>如果字段类型为int，而检索时加了单引号，则会隐式进行类型转换导致索引失效。</li>
</ol>
]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>intern()方法</title>
    <url>/2021/11/25/intern()%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>这两天被一个问题困扰住：intern()的作用，这里解释一下。</p>
<h2 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h2><p>在JDK1.6中，intern()是这样执行的：假设现在有”a”.intern()，就会先去找常量池中寻找有没有字面量为a的字符串，有的话直接返回该字符串在常量池的地址，没有的话就先创建一个，然后再返回在常量池中的地址。</p>
<h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><p>在JDK1.7中，intern()是这样执行的：同样是上面的例子，当在常量池寻找不到时，就会记录<strong>首次出现</strong>该字面量的字符串的引用地址，然后返回该引用地址，如果有的话就直接返回。</p>
<h2 id="For-Example"><a href="#For-Example" class="headerlink" title="For Example"></a>For Example</h2><p>举个例子周志明的《深入理解Java虚拟机》的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line">        </span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在JDK6中，会输出两个false，而在JDK7中，则会得到一个true一个false。在JDK6中，intern()方法会将首次遇到的字符串复制进常量池中保存，因此str1.intern()返回的是常量池中的引用，而在str1指向的对象是在堆中，因此返回false，这里解释一下，”java”这个字符串是在加载sum.misc.Version这个类的时候被加载进常量池的，因此下面会返回true。</p>
<p>在JDK7中，常量池被移到了堆中，因此只需要记录首次出现该字面量的字符串的引用地址即可，也就是堆中的地址，因此两个都是true。</p>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.8hashmap解析02</title>
    <url>/2021/11/24/jdk1-8hashmap%E8%A7%A3%E6%9E%9002/</url>
    <content><![CDATA[<h3 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h3><p>前情回顾：<a href="https://blog.csdn.net/weixin_46180709/article/details/121320440">谈谈jdk1.8的HashMap 01</a><br>上次我们把put方法讲完了，有一个方法我没有细说，那就是resize()方法，这个方法我个人认为是HashMap最精华但是却最难理解的地方，接下来我们慢慢讲解。</p>
<h2 id="回顾一下成员变量"><a href="#回顾一下成员变量" class="headerlink" title="回顾一下成员变量"></a>回顾一下成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="comment">//装Node的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//HashMap的大小</span></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">//容量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;<span class="comment">//负载因子</span></span><br></pre></td></tr></table></figure>

<h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h3><p>resize()方法的作用就是扩容还有初始化。</p>
<p>在该方法中，我们要着重注意old/newCap(旧/新数组长度)和old/newThr(旧/新容量)，</p>
<p>看看代码吧，部分解析已经写在了注释里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当第一次调用这个方法的是时候，oldCap和oldThr都为0,</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这一个判断就可以区别是初始化还是扩容了</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把长度和阈值都扩大了一倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若执行到这，则是初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">            <span class="comment">//如果能执行到这里，也就是说调用的是有参构造，oldThr必定是2的整数次幂</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//运行到这里就表示是调用了无参构造，进行初始化 </span></span><br><span class="line">        	<span class="comment">//16            </span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            <span class="comment">//12</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        	<span class="comment">//从这里开始把旧数组的数据复制到新数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里我个人认为是方便GC</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果该结点没有后续结点，则直接重新计算在新数组的位置，插入</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//下文详细说明</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="新旧数组数据迁移"><a href="#新旧数组数据迁移" class="headerlink" title="新旧数组数据迁移"></a>新旧数组数据迁移</h2><p>在jdk1.7中，每一个节点都要先经过一个扰动函数的计算后再重新计算下标，而在1.8中，是这么进行的….</p>
<p> 如果没有hash冲突，也就是说某节点没有next节点，那就直接和新数组长度取余获得下标，如果有hash冲突，那么就开始一个循环：首先定义四个Node类型变量：<br> loHead，loTail，hiHead，HiTail(其实就是low和high的缩写)，然后遍历该链表，把每一个结点的key的hash值与旧数组长度(<strong>假设是2的n次方</strong>)相与，<strong>目的是为了得到第n位的数是是否为0</strong>，如果是0，则把该结点放入以loHead为头，以loTail为尾的链表中，反之，则放入以hiHead为头，以hiHead为尾的链表。过程如下：</p>
<p>hash: 0000 0000 1110 1111<br>oldCap:0000 0000 0000 1000<br>相与的结果不是0，因此现在high链表中只有一个结点，接着遍历该结点的next结点，假设<br>hash: 0000 0000 1110 0111<br>oldCap:0000 0000 0000 1000<br>相与的结果是0，那么把该节点放入low链表中，接着遍历下一个结点，同样执行上述操作，如果结果是1，则放入high链表的尾部，重复上述过程直到next结点为null。</p>
<p>最后把low链表放到原位置，把high链表放到原位置+旧数组长度的位置，假设，Node数组长度为16，现在遍历到oldTable[2]，发现table[2]发生了哈希冲突，有Node1&lt;1,a&gt;，Node2&lt;2,b&gt;，Node3&lt;3,c&gt;，经过上述操作后，low链表有Node2和Node3，而high链表有Node1，则最后新数组是这样放的，在newTable[2]的地方放入Node2(next结点就是Node3)，在newTable[2+16] 的地方放入Node1，结束。</p>
<p>画个图加深理解吧</p>
<p><img src="https://img-blog.csdnimg.cn/d492c9afc8b74ec1abcc32e7161930ae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>经过上述运算后<br><img src="https://img-blog.csdnimg.cn/43155f8a02f74bbd82a820e7a85d3e4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>最后<br><img src="https://img-blog.csdnimg.cn/60eb367bc7b6445fb68b384dd6b6e140.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其实HashMap体现了一种懒加载的思想，当我们调用完构造方法后，成员变量里的table是还没有被赋值的，也就是说这个时候table=null，直到第一次执行put方法时才会进行初始化。</p>
]]></content>
      <tags>
        <tag>java集合类</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.8hashmap解析01</title>
    <url>/2021/11/24/jdk1.8hashmap%E8%A7%A3%E6%9E%9001/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是我们开发过程中最常用的集合类，也是面试的重灾区，我个人也在学习中，若有错误请纠正。</p>
<h2 id="HashMap的结构"><a href="#HashMap的结构" class="headerlink" title="HashMap的结构"></a>HashMap的结构</h2><p>HashMap的结构是数组+链表，我们存储的键值对，在HashMap中会被封装为一个Node内部类，而其存储单位就是Node，所以数组的类型是Node类型，而每一个Node都有一个next属性指向下一个Node，形成了一个单链表，</p>
<p>如图所示：<br><img src="https://img-blog.csdnimg.cn/82c22ed56f2a4efca9d0168a03e2dd93.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAS3Nzbj8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="成员变量-（部分）"><a href="#成员变量-（部分）" class="headerlink" title="成员变量 （部分）"></a>成员变量 （部分）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//默认容量为2^4=16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//最大容量为2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;//<span class="title">HashMap</span>的装载单位</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">transient</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;[] <span class="title">table</span></span>;<span class="comment">//装Node的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//HashMap的大小</span></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">//容量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;<span class="comment">//负载因子</span></span><br></pre></td></tr></table></figure>


<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>HashMap的table长度必须要是2的整数次幂，之后会讲原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">//0.75</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">		<span class="comment">//上面都是很简单的合法性检查，就不细说了</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">        <span class="comment">//会把容量设置为离initialCapacity最近的2的整次幂数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>假设我们是HashMap的开发者，我们要想想数据（键值对）该如何存放。</p>
<p>首先，我们要把键值对封装为一个<strong>Node对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是Node内部类的构造方法及其参数。</p>
<blockquote>
<p>put方法的源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hash()方法<br>这个方法用来根据用户传来的key返回一个哈希码，在该方法内部会调用key所对应的类的hashCode方法，可以自己重写hashCode方法。</p>
</blockquote>
<h3 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//resize方法的作用在这里是初始化</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">            <span class="comment">//根据hash值来确定Node存放在数组的哪一个位置</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//如果tab[i]为空则直接放入，否则将用尾插法进行插入。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//判断是不是同一个key，这里可以重写equals方法自己定义比较规则</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">                <span class="comment">//树化时的放置规则</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//尾插法</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//也就是说，当链表长度到8的时候就会树化</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//遇到了相同的就会直接结束</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是找到了相同的key，在上面的循环break之后，e一定不是null</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//在这里重新设置新值</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();<span class="comment">//如果size超过了阈值就会扩容</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于HashMap数组长度的问题"><a href="#关于HashMap数组长度的问题" class="headerlink" title="关于HashMap数组长度的问题"></a>关于HashMap数组长度的问题</h2><p>为什么一定要是2的整数次幂呢？是这样的，在插入数据时，是根据key的hash值和数组的长度取余得到的，假设key的hash值是h，长度是length，那么下标=h%length，取余还有一种更高效的算法：<strong>当length的值是2的n次方时，下标 = h&amp;(length-1)<strong>。<br>原理：假设我们要算11%4，先用我们熟悉的十进制来看，11÷4 = 2····3(余)，那么我们回到二进制的世界里，11 ÷ 4 = 1011(2) ÷ 0100(2) = 10 ···· 11(余) ，我们仔细观察一下这个11(2)是怎么来的：是1011的最低两位，为什么是两位呢，因为除数是4 = 2^2，因此我们发现了这么一个规律，当length=2的n次方时，余数就等于h的最低n位，那么问题来了，最低n为怎么来呢？没错，把除数-1，就可以得到0····1  （一共有n个1）了，因此和它进行与运算即可得到余数。</strong>因此length必须是2的n次方。</strong></p>
]]></content>
      <tags>
        <tag>java集合类</tag>
      </tags>
  </entry>
</search>
